좋은 객체 지향 설계의 5가지 원칙(SOLID)
SRP 단일 책임 원칙(한 클래스는 하나의 책임만 가진다)
OCP 개방-폐쇄 원칙(확장에는 열려 있으나 변경에는 닫혀 있어야 한다)
LSP 리스코프 치환원칙(프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다)
ISP 인터페이스 분리 원칙(특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다)
DIP 의존관계 역전 원칙(프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나)

OCP 개방-폐쇄 원칙을 지키위해 스프링 필요?
MemberRepository m = new MemoryMemberRepository(); //기존코드
MemberRepository m = new JdbcMemberRepository(); //변경코드
구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
다형성을 사용했지만 OCP원칙을 지킬 수 없다.(변경은 막고 확장만 가능해야함)
이 문제를 해결하기 위해선 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

LSP 단순히 컴파일에 성공하는 것을 넘어서는 이야기.
ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함

ISP 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리 
인터페이스를 작게작게 나눔으로 인터페이스가 명확해지고 대체가능성이 높아진다.

DIP 구현클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
역할에 의존하게 해야 한다는 것과 같다. 
ex) MemberRepository m = new JdbcMemberRepository(); <- 구현 클래스에 의존 DIP 위반

정리 

객체 지향의 핵심은 다형성
다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없음
다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
다형성 만으로는 OCP,DIP를 지킬 수 없다.

--------------------------------------------------------------------------------------

스프링은 다음 기술로 다형성 + OCP,DIP를 가능하게 지원
DI: 의존관계, 의존성주입
DI 컨테이너 제공

클라이언트 코드의 변경 없이 기능 확장
쉽게 부품을 교체하듯이 개발