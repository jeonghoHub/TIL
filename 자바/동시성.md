특정 작업이 동시다발적으로 이루어졌을때 공유자원에 대한 처리를 적절하게 처리하지 못할경우 생기는 문제를 race condition(경쟁상태) 라고한다.

id가 1인 재고를 조회하고 수량을 줄인 뒤 업데이트를 하는 기능이 있다면 여러 요청들이 있을때 다음과 같이 처리된다고 생각할 것이다.
<img width="967" alt="스크린샷 2024-03-18 오후 7 13 11" src="https://github.com/jeonghoHub/TIL/assets/84367108/4db2b890-a2d3-45d5-8aa5-0a5005ab2ddd">

하지만 Thread-1에서 작업을 미처 다 못끝내지 못했는데 Thread-2가 동일한 기능을 수행하려 한다면 흐름은 다음과 같이 흘러간다.

<img width="967" alt="스크린샷 2024-03-18 오후 7 19 58" src="https://github.com/jeonghoHub/TIL/assets/84367108/7ec2814c-ce76-4a68-9500-12326fe2934d">

두 스레드 모두 동일한 데이터를 가지고 있고 동일하게 업데이트를 한다. 이럴경우 똑같은 작업이 두번 일어낫기에 데이터 정합성이 어긋나게 되어버린다.

이런 문제를을 방지하기 위해서는 여러 방법들이 있는데 애플리케이션에서 synchronized를 걸어주거나 db의 lock, redis의 분산 lock, 메시지큐 (카프카, 래빗mq)등의 방식으로 처리 해야한다.
