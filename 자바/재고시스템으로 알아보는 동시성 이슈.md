특정 작업이 동시다발적으로 이루어졌을때 공유자원에 대한 처리를 적절하게 처리하지 못할경우 생기는 문제를 race condition(경쟁상태) 라고한다.

id가 1인 재고를 조회하고 수량을 줄인 뒤 업데이트를 하는 기능이 있다면 여러 요청들이 있을때 다음과 같이 처리된다고 생각할 것이다.
<img width="967" alt="스크린샷 2024-03-18 오후 7 13 11" src="https://github.com/jeonghoHub/TIL/assets/84367108/4db2b890-a2d3-45d5-8aa5-0a5005ab2ddd">

하지만 Thread-1에서 작업을 미처 다 못끝내지 못했는데 Thread-2가 동일한 기능을 수행하려 한다면 흐름은 다음과 같이 흘러간다.

<img width="967" alt="스크린샷 2024-03-18 오후 7 19 58" src="https://github.com/jeonghoHub/TIL/assets/84367108/7ec2814c-ce76-4a68-9500-12326fe2934d">

두 스레드 모두 동일한 데이터를 가지고 있고 동일하게 업데이트를 한다. 이럴경우 똑같은 작업이 두번 일어낫기에 데이터 정합성이 어긋나게 되어버린다.

이런 문제를을 방지하기 위해서는 여러 방법들이 있는데 애플리케이션에서 synchronized를 걸어주거나 db의 lock, redis의 분산 lock, 메시지큐 (카프카, 래빗mq)등의 방식으로 처리 해야한다.

## synchronized로 해결하기
자바에서는 synchronized라는 키워드로 스레드간의 동기화를 해줄 수 있다.

<img width="458" alt="스크린샷 2024-03-18 오후 7 31 19" src="https://github.com/jeonghoHub/TIL/assets/84367108/2ccd82a0-491a-4eb3-8db0-c002a2292ca2">

하지만 이 코드도 부실하다. 그 이유는 스프링의 @Transactional 어노테이션의 동작방식 때문인데, @Transactional은 다음과 같이 붙여진 메소드를 감싸 동작하게 된다.

<img width="751" alt="스크린샷 2024-03-18 오후 7 34 12" src="https://github.com/jeonghoHub/TIL/assets/84367108/4c32c990-4262-4f3f-93a7-4c047beef1fd">

간략하게 설명을하면 decrease 메서드가 호출이 되고 종료가 되고 난 후 db에 commit을 하게 되는데 이 db에 commit을하는 짧은 시점에서 스레드가 밀고 들어와 공유 자원에 접근하게 된다면 말짱 도루묵인 것이다.

1. decrease 메소드 시작
2. decrease 메소드 실행
3. decrease 메소드 종료
4. <요 사이에 스레드 접근>
5. db commit

이럴경우 @Transactional 어노테이션을 떼고 테스트를 한다면 성공한다. 하지만 이 방법은 하나의 프로세스에서만 보장하는 방식이기 때문에 서버를 하나만 가지고 운영하는게 아니라면 사용하지말자

## Database Lock

### Pessimistic Lock (비관적락)
트랜잭션이 특정 데이터를 읽고 수정하는 과정에서 다른 트랜잭션이 동시에 해당 데이터에 접근하지 못하도록 미리 이 데이터에 잠금을 거는 방식.
이런 방식은 동시성을처리할 때 충돌이 발생할 것이라고 "비관적"으로 가정하고 데이터의 일관성과 무결성을 유지하기 위해 사용한다.

구현 방식에는 다음과 같은 방법이 있다.

- Row-Level-Lock : 특정 레코드에 대한 잠금을 걸어 다른 트랜잭션이 해당 레코드를 수정하지 못하게 한다.
- Table-Level-Lock : 전체 테이블에 잠금을 걸어 트랜잭션이 해당 테이블의 어떠한 레코드도 수정하지 못하게 한다.

비관적 락은 데이터의 안정성을 보장하지만, 모든 요청마다 락을 걸기 때문에 시스템 전반적인 성능 저하 및 데드락과 같은 문제가 발생할 수 있다.

### Optimistic Lock (낙관적락)

낙관적락은 애플리케이션 단에서 레코드에 version을 주어 업데이트할 때마다 version 번호를 증가시킨다. 트랜잭션이 커밋되기 전, 저장된 버전 번호와 현재 버전 번호를 비교한다.
만약 번호가 다르다면, 다른 트랜잭션이 데이터를 변경한 것이므로 현재 트랜잭션은 실패한다.

데이터에 미리 락을 걸지 않기 때문에, 많은 수의 동시 트랜잭션 처리가 가능하고, 시스템의 동시성 수준이 향상된다.
또한, 락을 걸지 않기 때문에 데드락이 발생 가능성이 없다.

하지만 트랜잭션이 실패할 경우 재시도 해야하며, 이를 해결하는 로직이 구현되어야 한다는 단점이 있다.


### Named Lock


## Redis


[출처] 인프런 재고시스템으로 알아보는 동시성 이슈 해결방법 강의
