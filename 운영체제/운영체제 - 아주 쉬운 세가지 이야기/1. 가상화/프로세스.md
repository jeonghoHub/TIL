# 4. 프로세스

## 4.1 프로세스 개념
일반적으로 프로세스는 실행 중인 프로그램으로 정의됨.  
프로그램 자체는 생명이 없는 존재이며, 프로그램은 디스크상에 존재하며 실행을 위한  
명령어와 정적 데이터의 묶음이다. 이 명령어와 데이터 묶음을 읽고 실행하여  
프로그램에 생명을 불어넣는 것이 "운영체제"이다.  

사용자는 하나 이상의 프로그램을 동시에 실행시키기를 원하는데  
이를 CPU 가상화를 통해 이러한 환상을 만들어 낼 수 있다.  

하나의 프로세스를 실행하고, 중단시키고 다른 프로세스를 실행하는 작업을 반복하며(미친듯이 빠르게)  
실제 하나 또는 소수의 CPU로 여러 개의 가상 CPU가 존재하는 듯한 환상을 만들어 낸다.  
이러한 기법을 "시분할 기법"이라 하는데 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 해주지만,  
시분할 기법은 CPU를 공유하기 때문에, 각 프로세스의 성능은 낮아진다.  

CPU에서 프로그램 실행을 잠시 중단하고 다른 프로그램을 실행시키는 것을  
"문맥교환(context switch)"이라고 한다. 문맥교환이 자주 일어나면 날수록 프로그램은 느려질 것 이다.  

운영체제의 지능은 "정책(policy)"의 형태로 표현된다. 정책이란 운영체제에서 어떤  
결정을 내리는데 사용되는 알고리즘이다. 예를 들어 다수의 실행가능한 프로그램이  
존재할 떄, 운영체제는 "스케줄링 정책"이 결정한다. 이러한 결정을 내리기 위해  
스케줄링 정책은 과거정보, 워크로드에 관한 정보, 성능 및 측정 결과를 이용한다.  

## 4.2 프로세스 API  

생성(Create) : 운영체제는 새로운 프로세스를 생성할 수 있는 방법을 제공해야 한다.
			 쉘에 명령어를 입력하거나, 응용 프로그램의 아이콘을 더블-클릭하거나.  
			 
제거(Destroy) : 프로세스 생성 인터페이스를 제공하는 것처럼 운영체제는 프로세스를
			  강제로 제거할 수 있는 인터페이스를 제공해야 한다.  
			  
대기(Wait) : 때론 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 여러 종류의 대기 인터페이스가 제공됨.
  
각종제어(Miscellaneous Control) : 프로세스의 제거, 대기 이외에, 여러 가지 제어 기능들이 제공됨.
							   예를 들어, 대부분의 운영체제는 프로세스를 일시정지하거나 재개하는 기능을 제공함.  
							   
상태(Status) : 프로세스 상태 정보를 얻어내는 인터페이스도 제공된다.  
상태 정보에는 얼마동안 실행되었는지 또는 프로세스가 어떤 상태에 있는지 등이 포함됨.  

## 4.3 프로세스 생성: 좀 더 자세하게
프로그램이 프로세스로 변형되는 작업이 어떻게 이루어 지는것일까.

프로그램 코드와 정적 데이터(static data, 예를 들어 초기값을 가지는 변수)를 메모리, 프로세스의 주소 공간에 탑재한다.(load)
프로그램은 HDD 또는 SSD에 특정 실행 파일 형식으로 존재한다(.jar) 코드와 정적데이터를 메모리에 탑재하기 위해서
운영체제는 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 저장해야 한다.

초기 운영체제들은 프로그램 실행 전에 코드와 데이터를 모두 메모리에 탑재했음. 하지만 현대의 운영체제들은 이 작업을 늦추었다.
즉, 프로그램을 실행하면서 코드나 데이터가 필요할 때 필요한 부분만 메모리에 탑재한다. 코드와 데이터의 늦은 탑재의 동작을
이해하기 위해선 페이징과 스와핑 동작의 이해가 필요함.

코드와 정적 데이터가 메모리로 탑재된 후, 프로세스를 실행시키기 전에 운영체제가 해야 할 일이 몇 가지 있다.
특정 크기의 메모리 공간이 프로그램에 스택(run-time stack 혹은 그냥 스택) 용도로 할당되어야 하며,
프로그램의 힙(heap)을 위한 메모리 영역을 할당한다.

힙은 동적으로 할당된 데이터를 저장하기 위해 사용되며, 힙은 연결 리스트, 해시 테이블, 트리 등
크기가 가변적인 자료 구조를 위해 사용된다.

코드와 정적 데이터를 메모리에 탑재하고, 스택과 힙을 생성하고 초기화하고, 입출력 셋업과 관계된 다른 작업을 마치게 되면,
운영체제는 프로그램 실행을 위한 준비를 마치게 된다. 

프로그램의 시작 지점(entry point), 즉 main()에서부터 프로그램 실행을 시작하는 마지막 작업만이 남으며,
main() 루틴으로 분기함으로써 운영체제는 CPU를 새로 생성된 프로세스에게 넘기게 되고 프로그램 실행이 시작된다.
